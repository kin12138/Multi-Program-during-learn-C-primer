Poets and songwriters have a thing about love. And sometimes about counting. Occasionally
both. Inspired by the rather different takes on love and counting by Elizabeth
Barrett Browning (“How do I love thee? Let me count the ways.”) and Paul Simon
(“There must be 50 ways to leave your lover.”), we might try to enumerate the reasons
why a raw pointer is hard to love:
1. Its declaration doesn’t indicate whether it points to a single object or to an array.
2. Its declaration reveals nothing about whether you should destroy what it points
to when you’re done using it, i.e., if the pointer owns the thing it points to.
3. If you determine that you should destroy what the pointer points to, there’s no
way to tell how. Should you use delete, or is there a different destruction mechanism
(e.g., a dedicated destruction function the pointer should be passed to)?
4. If you manage to find out that delete is the way to go, Reason 1 means it may
not be possible to know whether to use the single-object form (“delete”) or the
array form (“delete []”). If you use the wrong form, results are undefined.
5. Assuming you ascertain that the pointer owns what it points to, and you discover
how to destroy it, it’s difficult to ensure that you perform the destruction exactly
once along every path in your code (including those due to exceptions). Missing a
path leads to resource leaks, and doing the destruction more than once leads to
undefined behavior.
6. There’s typically no way to tell if the pointer dangles, i.e., points to memory that
no longer holds the object the pointer is supposed to point to. Dangling pointers
arise when objects are destroyed while pointers still point to them.
Raw pointers are powerful tools, to be sure, but decades of experience have demonstrated
that with only the slightest lapse in concentration or discipline, these tools can
turn on their ostensible masters.
Smart pointers are one way to address these issues. Smart pointers are wrappers
around raw pointers that act much like the raw pointers they wrap, but that avoid
many of their pitfalls. You should therefore prefer smart pointers to raw pointers.
Smart pointers can do virtually everything raw pointers can, but with far fewer
opportunities for error.
There are four smart pointers in C++11: std::auto_ptr, std::unique_ptr,
std::shared_ptr, and std::weak_ptr. All are designed to help manage the lifetimes
of dynamically allocated objects, i.e., to avoid resource leaks by ensuring that
such objects are destroyed in the appropriate manner at the appropriate time (including
in the event of exceptions).
std::auto_ptr is a deprecated leftover from C++98. It was an attempt to standardize
what later became C++11’s std::unique_ptr. Doing the job right required move
semantics, but C++98 didn’t have them. As a workaround, std::auto_ptr co-opted
its copy operations for moves. This led to surprising code (copying a std::auto_ptr
sets it to null!) and frustrating usage restrictions (e.g., it’s not possible to store
std::auto_ptrs in containers).
std::unique_ptr does everything std::auto_ptr does, plus more. It does it as efficiently,
and it does it without warping what it means to copy an object. It’s better
than std::auto_ptr in every way. The only legitimate use case for std::auto_ptr
is a need to compile code with C++98 compilers. Unless you have that constraint,
you should replace std::auto_ptr with std::unique_ptr and never look back.
The smart pointer APIs are remarkably varied. About the only functionality common
to all is default construction. Because comprehensive references for these APIs are
widely available, I’ll focus my discussions on information that’s often missing from
API overviews, e.g., noteworthy use cases, runtime cost analyses, etc. Mastering such
information can be the difference between merely using these smart pointers and
using them effectively.